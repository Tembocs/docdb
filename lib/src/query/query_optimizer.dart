/// Query optimizer for DocDB.
///
/// This module provides intelligent query execution planning with:
/// - Index statistics collection (cardinality, selectivity)
/// - Cost-based query plan generation
/// - Automatic index selection for optimal performance
/// - Query plan caching for repeated queries
///
/// ## Overview
///
/// The query optimizer analyzes queries and available indexes to determine
/// the most efficient execution strategy. It considers:
///
/// - Index type (hash vs btree) and suitability for query type
/// - Index selectivity (how much the index narrows down results)
/// - Estimated result set size
/// - I/O cost vs scan cost tradeoffs
///
/// ## Usage
///
/// ```dart
/// final optimizer = QueryOptimizer(indexManager);
///
/// // Generate optimal execution plan
/// final plan = optimizer.optimize(query, totalEntityCount);
///
/// // Execute using the plan
/// if (plan.strategy == ExecutionStrategy.indexScan) {
///   final ids = indexManager.search(plan.indexField!, plan.indexValue!);
///   // ... fetch entities by ids
/// } else {
///   // Full scan with filter
/// }
/// ```
library;

import 'package:meta/meta.dart';

import '../index/index_manager.dart';
import '../index/i_index.dart';
import 'query_types.dart';

// =============================================================================
// Index Statistics
// =============================================================================

/// Statistics about an index for query optimization.
///
/// These statistics help the optimizer estimate query costs and
/// choose the most efficient execution strategy.
@immutable
class IndexStatistics {
  /// The field name this index covers.
  final String field;

  /// The type of index (hash or btree).
  final IndexType indexType;

  /// Number of unique keys in the index.
  ///
  /// High cardinality (many unique values) indicates good selectivity.
  final int cardinality;

  /// Total number of entity references in the index.
  ///
  /// May be greater than cardinality if multiple entities share keys.
  final int totalEntries;

  /// Estimated selectivity (0.0 to 1.0).
  ///
  /// Lower values indicate better selectivity (fewer entities per key).
  /// Calculated as 1 / cardinality when cardinality > 0.
  double get selectivity {
    if (cardinality == 0) return 1.0;
    return 1.0 / cardinality;
  }

  /// Average number of entities per unique key.
  double get averageEntriesPerKey {
    if (cardinality == 0) return 0.0;
    return totalEntries / cardinality;
  }

  /// Creates index statistics.
  const IndexStatistics({
    required this.field,
    required this.indexType,
    required this.cardinality,
    required this.totalEntries,
  });

  @override
  String toString() {
    return 'IndexStatistics(field: $field, type: ${indexType.name}, '
        'cardinality: $cardinality, entries: $totalEntries, '
        'selectivity: ${selectivity.toStringAsFixed(4)})';
  }
}

// =============================================================================
// Execution Strategy
// =============================================================================

/// The execution strategy for a query.
enum ExecutionStrategy {
  /// Use an index to find matching entity IDs, then fetch entities.
  ///
  /// Best when index is selective and matches a small percentage of entities.
  indexScan,

  /// Scan all entities and filter using the query predicate.
  ///
  /// Best when no suitable index exists or index would return most entities.
  fullScan,

  /// Use an index for the primary filter, then apply additional filters.
  ///
  /// Used for compound queries where only some conditions are indexed.
  indexScanWithFilter,

  /// Use multiple indexes and intersect results.
  ///
  /// Used for AND queries where multiple conditions have indexes.
  multiIndexIntersect,

  /// Use multiple indexes and union results.
  ///
  /// Used for OR queries where conditions have indexes.
  multiIndexUnion,
}

// =============================================================================
// Query Plan
// =============================================================================

/// A query execution plan generated by the optimizer.
///
/// Contains the chosen execution strategy and all information needed
/// to execute the query optimally.
@immutable
class QueryPlan {
  /// The execution strategy to use.
  final ExecutionStrategy strategy;

  /// The original query.
  final IQuery query;

  /// Estimated cost of this plan (lower is better).
  ///
  /// Cost is a relative measure combining:
  /// - Number of index lookups
  /// - Estimated entities to scan
  /// - Filter complexity
  final double estimatedCost;

  /// Estimated number of results.
  final int estimatedResults;

  /// The index field to use (for index-based strategies).
  final String? indexField;

  /// The index type being used.
  final IndexType? indexType;

  /// Index lookup value for equality queries.
  final dynamic indexValue;

  /// Range bounds for range queries.
  final RangeBounds? rangeBounds;

  /// Values for IN queries.
  final List<dynamic>? inValues;

  /// Sub-plans for compound queries.
  final List<QueryPlan>? subPlans;

  /// Filter to apply after index scan.
  final IQuery? postFilter;

  /// Whether this plan uses an index.
  bool get usesIndex => strategy != ExecutionStrategy.fullScan;

  /// Creates a query plan.
  const QueryPlan({
    required this.strategy,
    required this.query,
    required this.estimatedCost,
    required this.estimatedResults,
    this.indexField,
    this.indexType,
    this.indexValue,
    this.rangeBounds,
    this.inValues,
    this.subPlans,
    this.postFilter,
  });

  /// Creates a full scan plan.
  factory QueryPlan.fullScan({
    required IQuery query,
    required int totalEntities,
  }) {
    return QueryPlan(
      strategy: ExecutionStrategy.fullScan,
      query: query,
      // Full scan cost is proportional to total entities
      estimatedCost: totalEntities.toDouble(),
      estimatedResults: totalEntities,
    );
  }

  /// Creates an index scan plan for equality query.
  factory QueryPlan.indexEquals({
    required IQuery query,
    required String field,
    required IndexType indexType,
    required dynamic value,
    required int estimatedResults,
    required int totalEntities,
  }) {
    // Index lookup cost + fetch cost
    final cost = _calculateIndexCost(estimatedResults, totalEntities);
    return QueryPlan(
      strategy: ExecutionStrategy.indexScan,
      query: query,
      estimatedCost: cost,
      estimatedResults: estimatedResults,
      indexField: field,
      indexType: indexType,
      indexValue: value,
    );
  }

  /// Creates an index scan plan for range query.
  factory QueryPlan.indexRange({
    required IQuery query,
    required String field,
    required RangeBounds bounds,
    required int estimatedResults,
    required int totalEntities,
  }) {
    final cost = _calculateIndexCost(estimatedResults, totalEntities);
    return QueryPlan(
      strategy: ExecutionStrategy.indexScan,
      query: query,
      estimatedCost: cost,
      estimatedResults: estimatedResults,
      indexField: field,
      indexType: IndexType.btree,
      rangeBounds: bounds,
    );
  }

  /// Creates an index scan plan for IN query.
  factory QueryPlan.indexIn({
    required IQuery query,
    required String field,
    required IndexType indexType,
    required List<dynamic> values,
    required int estimatedResults,
    required int totalEntities,
  }) {
    // Multiple lookups cost
    final cost =
        _calculateIndexCost(estimatedResults, totalEntities) + values.length;
    return QueryPlan(
      strategy: ExecutionStrategy.indexScan,
      query: query,
      estimatedCost: cost,
      estimatedResults: estimatedResults,
      indexField: field,
      indexType: indexType,
      inValues: values,
    );
  }

  /// Creates a multi-index intersection plan.
  factory QueryPlan.intersection({
    required IQuery query,
    required List<QueryPlan> subPlans,
    required int estimatedResults,
  }) {
    final cost = subPlans.fold<double>(
      0.0,
      (sum, plan) => sum + plan.estimatedCost,
    );
    return QueryPlan(
      strategy: ExecutionStrategy.multiIndexIntersect,
      query: query,
      estimatedCost: cost,
      estimatedResults: estimatedResults,
      subPlans: subPlans,
    );
  }

  /// Creates a multi-index union plan.
  factory QueryPlan.union({
    required IQuery query,
    required List<QueryPlan> subPlans,
    required int estimatedResults,
  }) {
    final cost = subPlans.fold<double>(
      0.0,
      (sum, plan) => sum + plan.estimatedCost,
    );
    return QueryPlan(
      strategy: ExecutionStrategy.multiIndexUnion,
      query: query,
      estimatedCost: cost,
      estimatedResults: estimatedResults,
      subPlans: subPlans,
    );
  }

  /// Creates an index scan with post-filter plan.
  factory QueryPlan.indexWithFilter({
    required IQuery query,
    required QueryPlan indexPlan,
    required IQuery postFilter,
    required int estimatedResults,
  }) {
    // Add filter cost
    final cost = indexPlan.estimatedCost + (indexPlan.estimatedResults * 0.1);
    return QueryPlan(
      strategy: ExecutionStrategy.indexScanWithFilter,
      query: query,
      estimatedCost: cost,
      estimatedResults: estimatedResults,
      indexField: indexPlan.indexField,
      indexType: indexPlan.indexType,
      indexValue: indexPlan.indexValue,
      rangeBounds: indexPlan.rangeBounds,
      inValues: indexPlan.inValues,
      postFilter: postFilter,
    );
  }

  /// Calculates index lookup cost.
  static double _calculateIndexCost(int resultCount, int totalEntities) {
    // Base cost for index lookup
    const baseCost = 1.0;
    // Cost per result fetch
    const fetchCostPerEntity = 0.5;
    return baseCost + (resultCount * fetchCostPerEntity);
  }

  @override
  String toString() {
    final buffer = StringBuffer('QueryPlan(');
    buffer.write('strategy: ${strategy.name}');
    buffer.write(', cost: ${estimatedCost.toStringAsFixed(2)}');
    buffer.write(', results: ~$estimatedResults');
    if (indexField != null) {
      buffer.write(', index: $indexField');
    }
    buffer.write(')');
    return buffer.toString();
  }
}

/// Range bounds for range queries.
@immutable
class RangeBounds {
  /// Lower bound value.
  final dynamic lower;

  /// Upper bound value.
  final dynamic upper;

  /// Whether lower bound is inclusive.
  final bool includeLower;

  /// Whether upper bound is inclusive.
  final bool includeUpper;

  /// Creates range bounds.
  const RangeBounds({
    this.lower,
    this.upper,
    this.includeLower = true,
    this.includeUpper = false,
  });

  /// Creates bounds for greater than.
  const RangeBounds.greaterThan(dynamic value)
    : lower = value,
      upper = null,
      includeLower = false,
      includeUpper = false;

  /// Creates bounds for greater than or equal.
  const RangeBounds.greaterThanOrEqual(dynamic value)
    : lower = value,
      upper = null,
      includeLower = true,
      includeUpper = false;

  /// Creates bounds for less than.
  const RangeBounds.lessThan(dynamic value)
    : lower = null,
      upper = value,
      includeLower = false,
      includeUpper = false;

  /// Creates bounds for less than or equal.
  const RangeBounds.lessThanOrEqual(dynamic value)
    : lower = null,
      upper = value,
      includeLower = false,
      includeUpper = true;
}

// =============================================================================
// Query Plan Cache
// =============================================================================

/// Cache for query execution plans.
///
/// Caches plans based on query structure to avoid repeated optimization
/// for the same query patterns.
class QueryPlanCache {
  /// Maximum number of cached plans.
  final int maxSize;

  /// Cached plans keyed by query hash.
  final Map<String, _CacheEntry> _cache = {};

  /// Access order for LRU eviction.
  final List<String> _accessOrder = [];

  /// Creates a query plan cache.
  QueryPlanCache({this.maxSize = 100});

  /// Gets a cached plan for the query.
  ///
  /// Returns null if no cached plan exists or if the plan is stale.
  QueryPlan? get(IQuery query, int currentEntityCount) {
    final key = _computeKey(query);
    final entry = _cache[key];

    if (entry == null) {
      return null;
    }

    // Invalidate if entity count changed significantly (>10%)
    final countDiff = (entry.entityCount - currentEntityCount).abs();
    if (countDiff > entry.entityCount * 0.1) {
      _cache.remove(key);
      _accessOrder.remove(key);
      return null;
    }

    // Update access order for LRU
    _accessOrder.remove(key);
    _accessOrder.add(key);

    return entry.plan;
  }

  /// Caches a query plan.
  void put(IQuery query, QueryPlan plan, int entityCount) {
    final key = _computeKey(query);

    // Evict LRU entry if at capacity
    if (_cache.length >= maxSize && !_cache.containsKey(key)) {
      final lruKey = _accessOrder.removeAt(0);
      _cache.remove(lruKey);
    }

    _cache[key] = _CacheEntry(plan: plan, entityCount: entityCount);
    _accessOrder.remove(key);
    _accessOrder.add(key);
  }

  /// Clears all cached plans.
  void clear() {
    _cache.clear();
    _accessOrder.clear();
  }

  /// Invalidates cache entries for a specific field.
  ///
  /// Call this when an index on the field is created or removed.
  /// Uses a conservative approach - clears all entries to ensure
  /// no stale plans remain.
  void invalidateField(String field) {
    // For simplicity and correctness, clear all cache entries
    // when an index changes. This ensures no stale plans are used.
    // A more sophisticated approach would parse the query structure.
    clear();
  }

  /// Number of cached plans.
  int get size => _cache.length;

  /// Computes cache key from query.
  String _computeKey(IQuery query) {
    return query.toMap().toString();
  }
}

/// Internal cache entry.
class _CacheEntry {
  final QueryPlan plan;
  final int entityCount;

  _CacheEntry({required this.plan, required this.entityCount});
}

// =============================================================================
// Query Optimizer
// =============================================================================

/// Query optimizer that generates execution plans for queries.
///
/// The optimizer analyzes queries and available indexes to determine
/// the most efficient execution strategy based on cost estimation.
///
/// ## Cost Model
///
/// The optimizer uses a simple cost model:
/// - Full scan: cost = total_entities
/// - Index scan: cost = 1 + (estimated_results * 0.5)
/// - Lower cost is better
///
/// ## Index Selection
///
/// For queries that could use multiple indexes, the optimizer:
/// 1. Identifies all applicable indexes
/// 2. Estimates selectivity for each
/// 3. Chooses the most selective index
/// 4. Falls back to full scan if no index is beneficial
///
/// ## Usage
///
/// ```dart
/// final optimizer = QueryOptimizer(indexManager);
/// final plan = optimizer.optimize(query, totalEntities);
///
/// switch (plan.strategy) {
///   case ExecutionStrategy.indexScan:
///     // Use index
///     break;
///   case ExecutionStrategy.fullScan:
///     // Scan all
///     break;
///   // ...
/// }
/// ```
class QueryOptimizer {
  /// The index manager to query for index information.
  final IndexManager _indexManager;

  /// Query plan cache for repeated queries.
  final QueryPlanCache _planCache;

  /// Whether to use plan caching.
  final bool enableCaching;

  /// Threshold below which full scan is preferred over index.
  ///
  /// If estimated results exceed this fraction of total entities,
  /// a full scan may be more efficient than an index scan.
  static const double _fullScanThreshold = 0.3;

  /// Creates a query optimizer.
  ///
  /// - [indexManager]: The index manager for this collection.
  /// - [enableCaching]: Whether to cache query plans.
  /// - [cacheSize]: Maximum number of cached plans.
  QueryOptimizer(
    this._indexManager, {
    this.enableCaching = true,
    int cacheSize = 100,
  }) : _planCache = QueryPlanCache(maxSize: cacheSize);

  /// Generates an optimized execution plan for the query.
  ///
  /// - [query]: The query to optimize.
  /// - [totalEntities]: Total number of entities in the collection.
  ///
  /// Returns the optimal execution plan.
  QueryPlan optimize(IQuery query, int totalEntities) {
    if (totalEntities == 0) {
      return QueryPlan.fullScan(query: query, totalEntities: 0);
    }

    // Check cache first
    if (enableCaching) {
      final cachedPlan = _planCache.get(query, totalEntities);
      if (cachedPlan != null) {
        return cachedPlan;
      }
    }

    // Generate plan
    final plan = _optimizeInternal(query, totalEntities);

    // Cache the plan
    if (enableCaching) {
      _planCache.put(query, plan, totalEntities);
    }

    return plan;
  }

  /// Internal optimization logic.
  QueryPlan _optimizeInternal(IQuery query, int totalEntities) {
    // Handle AllQuery - always full scan
    if (query is AllQuery) {
      return QueryPlan.fullScan(query: query, totalEntities: totalEntities);
    }

    // Handle EqualsQuery
    if (query is EqualsQuery) {
      return _optimizeEquals(query, totalEntities);
    }

    // Handle range queries
    if (query is GreaterThanQuery) {
      return _optimizeRange(
        query,
        query.field,
        RangeBounds.greaterThan(query.value),
        totalEntities,
      );
    }

    if (query is GreaterThanOrEqualsQuery) {
      return _optimizeRange(
        query,
        query.field,
        RangeBounds.greaterThanOrEqual(query.value),
        totalEntities,
      );
    }

    if (query is LessThanQuery) {
      return _optimizeRange(
        query,
        query.field,
        RangeBounds.lessThan(query.value),
        totalEntities,
      );
    }

    if (query is LessThanOrEqualsQuery) {
      return _optimizeRange(
        query,
        query.field,
        RangeBounds.lessThanOrEqual(query.value),
        totalEntities,
      );
    }

    if (query is BetweenQuery) {
      return _optimizeBetween(query, totalEntities);
    }

    // Handle InQuery
    if (query is InQuery) {
      return _optimizeIn(query, totalEntities);
    }

    // Handle AndQuery
    if (query is AndQuery) {
      return _optimizeAnd(query, totalEntities);
    }

    // Handle OrQuery
    if (query is OrQuery) {
      return _optimizeOr(query, totalEntities);
    }

    // Handle NotQuery
    if (query is NotQuery) {
      // NOT queries typically require full scan
      return QueryPlan.fullScan(query: query, totalEntities: totalEntities);
    }

    // Default: full scan for other query types
    return QueryPlan.fullScan(query: query, totalEntities: totalEntities);
  }

  /// Optimizes an EqualsQuery.
  QueryPlan _optimizeEquals(EqualsQuery query, int totalEntities) {
    // Check for hash index (preferred for equality)
    if (_indexManager.hasIndexOfType(query.field, IndexType.hash)) {
      final stats = getIndexStatistics(query.field);
      if (stats != null) {
        final estimatedResults = stats.averageEntriesPerKey.ceil();
        return QueryPlan.indexEquals(
          query: query,
          field: query.field,
          indexType: IndexType.hash,
          value: query.value,
          estimatedResults: estimatedResults,
          totalEntities: totalEntities,
        );
      }
    }

    // Check for btree index (can also do equality)
    if (_indexManager.hasIndexOfType(query.field, IndexType.btree)) {
      final stats = getIndexStatistics(query.field);
      if (stats != null) {
        final estimatedResults = stats.averageEntriesPerKey.ceil();
        return QueryPlan.indexEquals(
          query: query,
          field: query.field,
          indexType: IndexType.btree,
          value: query.value,
          estimatedResults: estimatedResults,
          totalEntities: totalEntities,
        );
      }
    }

    // No suitable index
    return QueryPlan.fullScan(query: query, totalEntities: totalEntities);
  }

  /// Optimizes a range query.
  QueryPlan _optimizeRange(
    IQuery query,
    String field,
    RangeBounds bounds,
    int totalEntities,
  ) {
    // Only btree indexes support range queries
    if (!_indexManager.hasIndexOfType(field, IndexType.btree)) {
      return QueryPlan.fullScan(query: query, totalEntities: totalEntities);
    }

    final stats = getIndexStatistics(field);
    if (stats == null) {
      return QueryPlan.fullScan(query: query, totalEntities: totalEntities);
    }

    // Estimate results based on range (rough estimate: 50% of entities)
    // In practice, this would use histogram data for better estimates
    final estimatedResults = (totalEntities * 0.5).ceil();

    // Check if full scan would be better
    if (estimatedResults > totalEntities * _fullScanThreshold) {
      // Compare costs
      final indexPlan = QueryPlan.indexRange(
        query: query,
        field: field,
        bounds: bounds,
        estimatedResults: estimatedResults,
        totalEntities: totalEntities,
      );
      final fullScanPlan = QueryPlan.fullScan(
        query: query,
        totalEntities: totalEntities,
      );

      return indexPlan.estimatedCost < fullScanPlan.estimatedCost
          ? indexPlan
          : fullScanPlan;
    }

    return QueryPlan.indexRange(
      query: query,
      field: field,
      bounds: bounds,
      estimatedResults: estimatedResults,
      totalEntities: totalEntities,
    );
  }

  /// Optimizes a BetweenQuery.
  QueryPlan _optimizeBetween(BetweenQuery query, int totalEntities) {
    return _optimizeRange(
      query,
      query.field,
      RangeBounds(
        lower: query.lowerBound,
        upper: query.upperBound,
        includeLower: query.includeLower,
        includeUpper: query.includeUpper,
      ),
      totalEntities,
    );
  }

  /// Optimizes an InQuery.
  QueryPlan _optimizeIn(InQuery query, int totalEntities) {
    // Check for any index on the field
    if (!_indexManager.hasIndex(query.field)) {
      return QueryPlan.fullScan(query: query, totalEntities: totalEntities);
    }

    final stats = getIndexStatistics(query.field);
    if (stats == null) {
      return QueryPlan.fullScan(query: query, totalEntities: totalEntities);
    }

    // Estimate results: values count * average per key
    final estimatedResults = (query.values.length * stats.averageEntriesPerKey)
        .ceil();

    // Too many values might make full scan better
    if (query.values.length > 100 ||
        estimatedResults > totalEntities * _fullScanThreshold) {
      return QueryPlan.fullScan(query: query, totalEntities: totalEntities);
    }

    final indexType = _indexManager.hasIndexOfType(query.field, IndexType.hash)
        ? IndexType.hash
        : IndexType.btree;

    return QueryPlan.indexIn(
      query: query,
      field: query.field,
      indexType: indexType,
      values: query.values,
      estimatedResults: estimatedResults,
      totalEntities: totalEntities,
    );
  }

  /// Optimizes an AndQuery.
  QueryPlan _optimizeAnd(AndQuery query, int totalEntities) {
    // Find the most selective indexed sub-query
    QueryPlan? bestPlan;
    final remainingQueries = <IQuery>[];

    for (final subQuery in query.queries) {
      final subPlan = _optimizeInternal(subQuery, totalEntities);

      if (subPlan.usesIndex) {
        if (bestPlan == null ||
            subPlan.estimatedCost < bestPlan.estimatedCost) {
          if (bestPlan != null) {
            remainingQueries.add(bestPlan.query);
          }
          bestPlan = subPlan;
        } else {
          remainingQueries.add(subQuery);
        }
      } else {
        remainingQueries.add(subQuery);
      }
    }

    // No indexed sub-queries - full scan
    if (bestPlan == null) {
      return QueryPlan.fullScan(query: query, totalEntities: totalEntities);
    }

    // Single indexed condition, no filters needed
    if (remainingQueries.isEmpty) {
      return bestPlan;
    }

    // Index scan with post-filter
    final postFilter = remainingQueries.length == 1
        ? remainingQueries.first
        : AndQuery(remainingQueries);

    return QueryPlan.indexWithFilter(
      query: query,
      indexPlan: bestPlan,
      postFilter: postFilter,
      // Estimate that filter reduces results by 50%
      estimatedResults: (bestPlan.estimatedResults * 0.5).ceil(),
    );
  }

  /// Optimizes an OrQuery.
  QueryPlan _optimizeOr(OrQuery query, int totalEntities) {
    final subPlans = <QueryPlan>[];
    bool allIndexed = true;

    for (final subQuery in query.queries) {
      final subPlan = _optimizeInternal(subQuery, totalEntities);
      subPlans.add(subPlan);

      if (!subPlan.usesIndex) {
        allIndexed = false;
      }
    }

    // If all sub-queries can use indexes, create a union plan
    if (allIndexed) {
      // Estimate results as sum of sub-plans (may overestimate due to overlap)
      final estimatedResults = subPlans.fold<int>(
        0,
        (sum, plan) => sum + plan.estimatedResults,
      );

      final unionPlan = QueryPlan.union(
        query: query,
        subPlans: subPlans,
        estimatedResults: estimatedResults.clamp(0, totalEntities),
      );

      // Compare to full scan
      final fullScanPlan = QueryPlan.fullScan(
        query: query,
        totalEntities: totalEntities,
      );

      return unionPlan.estimatedCost < fullScanPlan.estimatedCost
          ? unionPlan
          : fullScanPlan;
    }

    // Mixed or no indexes - use full scan
    return QueryPlan.fullScan(query: query, totalEntities: totalEntities);
  }

  /// Gets statistics for an index.
  ///
  /// Returns null if no index exists on the field.
  IndexStatistics? getIndexStatistics(String field) {
    if (!_indexManager.hasIndex(field)) {
      return null;
    }

    final indexType = _indexManager.getIndexType(field);
    if (indexType == null) {
      return null;
    }

    // Get stats from index manager
    final cardinality = _indexManager.getCardinality(field);
    final totalEntries = _indexManager.getTotalEntries(field);

    return IndexStatistics(
      field: field,
      indexType: indexType,
      cardinality: cardinality,
      totalEntries: totalEntries,
    );
  }

  /// Gets statistics for all indexes.
  List<IndexStatistics> getAllIndexStatistics() {
    return _indexManager.indexedFields
        .map((field) => getIndexStatistics(field))
        .whereType<IndexStatistics>()
        .toList();
  }

  /// Clears the plan cache.
  void clearCache() {
    _planCache.clear();
  }

  /// Invalidates cached plans for a specific field.
  ///
  /// Call this when an index is created or removed.
  void invalidateField(String field) {
    _planCache.invalidateField(field);
  }

  /// Gets the plan cache for inspection.
  @visibleForTesting
  QueryPlanCache get planCache => _planCache;
}
